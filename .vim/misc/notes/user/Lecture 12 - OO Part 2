Lecture 12 - OO Part 2

 • Superclasses
    ◦ Subclasses inherit all variables and methods from superclasses
    ◦ Code reuse!
    ◦ Subclasses may override any aspect of the superclass
 • Inheritance
    ◦ class C1(C2, C3)
       ▸ We look first at C1, then C2, then C3
          ▹ Left to right
 • Private(ish) methods

      class Person:
         def public_method(self): ...
         def ___private_method(self): ...
         def set_some_vars(self):
            self.foo = true  # public
            self.___foo = True # private-ish

    ◦ Can technically still call private methods
       ▸ However, you make them private for a reason
          ▹ “We are all adults here” -Guido van Rossum
 • Decorators

      @classmethod
      def this_is_a_class(cls,...):

      @staticmethod
      def this_is_static(...):

      this_is_static = staticmethod(this_is_static)

 • Testing Classes
      
      class Person:
         def main(argv=sys.argv[1:])
            parse_args(argv)

      if ___name___ = “__main__”:
         brian = Person(“Brian”)
         brian.test()

    ◦ If called from the command line will run the above code

 • Custom Exceptions
    ◦ usually just an empty class
    ◦ Sometimes add a ___str___() method

 • Operator Overloading
    ◦ ___add___() for +
    ◦ ___sub___() for -
    ◦ ___gt___() for >
    ◦ etc.
    ◦ ___str___(self):
       ▸ equivalent to a toString method
       ▸ meant to be human-readable
    ◦ ___repr___(self):
       ▸ Meant to be an unambiguous form of toString
       ▸ Prints everything in order to be unambiguous

 • Introspection
    ◦ can use var.___dict___.keys() to show all variable names

 • Saving State
    ◦ pickle
    ◦ Can save state between runs
